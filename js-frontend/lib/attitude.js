'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var cart2sph;
var combinedErrors$1;
var convolveAxes;
var d3$1;
var deconvolveAxes;
var ellipse;
var identity;
var norm;
var normalErrors;
var planeErrors;
var sdot;
var transpose;

d3$1 = require('d3');

transpose = function(array, length = null) {
  var i, j, k, l, m, newArray, ref, ref1, results;
  if (length == null) {
    length = array[0].length;
  }
  newArray = (function() {
    results = [];
    for (var k = 0; 0 <= length ? k < length : k > length; 0 <= length ? k++ : k--){ results.push(k); }
    return results;
  }).apply(this).map(function() {
    return [];
  });
  for (i = l = 0, ref = array.length; 0 <= ref ? l < ref : l > ref; i = 0 <= ref ? ++l : --l) {
    for (j = m = 0, ref1 = length; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
      newArray[j].push(array[i][j]);
    }
  }
  return newArray;
};

identity = [[1, 0, 0], [0, 1, 0], [0, 0, 1]];

norm = function(d) {
  var _;
  // L2 norm (hypotenuse)
  _ = d.map(function(a) {
    return a * a;
  });
  return Math.sqrt(d3$1.sum(_));
};

sdot = function(a, b) {
  var i, zipped;
  zipped = (function() {
    var k, ref, results;
    results = [];
    for (i = k = 0, ref = a.length; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      results.push(a[i] * b[i]);
    }
    return results;
  })();
  return d3$1.sum(zipped);
};

ellipse = function(opts) {
  var ell, ellAdaptive;
  // Basic function to create an array
  // of cosines and sines for error-ellipse
  // generation
  if (opts.n == null) {
    opts.n = 50;
  }
  if (opts.adaptive == null) {
    opts.adaptive = true;
  }
  ellAdaptive = function(a, b) {
    var angles, i, i_, k, l, ref, ref1, step, v;
    // Takes major, minor axis lengths
    i_ = 1;
    v = opts.n / 2;
    step = 2 / v;
    // Make a linearly varying space on the
    // interval [1,-1]
    angles = [];
    angles.push(Math.PI - Math.asin(i_));
    for (i = k = 0, ref = v; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
      i_ -= step;
      angles.push(Math.PI - Math.asin(i_));
    }
    for (i = l = 0, ref1 = v; 0 <= ref1 ? l < ref1 : l > ref1; i = 0 <= ref1 ? ++l : --l) {
      i_ += step;
      v = Math.asin(i_);
      if (v < 0) {
        v += 2 * Math.PI;
      }
      angles.push(v);
    }
    return (function() {
      var len, m, results;
      results = [];
      for (m = 0, len = angles.length; m < len; m++) {
        i = angles[m];
        results.push([b * Math.cos(i), a * Math.sin(i)]);
      }
      return results;
    })();
  };
  ell = function(a, b) {
    var angles, i, step;
    step = 2 * Math.PI / (opts.n - 1);
    angles = (function() {
      var k, ref, results;
      results = [];
      for (i = k = 0, ref = opts.n; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
        results.push(i * step);
      }
      return results;
    })();
    return (function() {
      var k, len, results;
      results = [];
      for (k = 0, len = angles.length; k < len; k++) {
        i = angles[k];
        // This reversal of B and A is causing tests to fail
        results.push([b * Math.cos(i), a * Math.sin(i)]);
      }
      return results;
    })();
  };
  if (opts.adaptive) {
    return ellAdaptive;
  } else {
    return ell;
  }
};

cart2sph = function(opts) {
  var c;
  if (opts.degrees == null) {
    opts.degrees = false;
  }
  c = opts.degrees ? 180 / Math.PI : 1;
  return function(d) {
    var r, x, y, z;
    r = norm(d);
    if (opts.traditionalLayout) {
      [y, z, x] = d;
    } else {
      [y, x, z] = d;
      x *= -1;
    }
    if (!opts.upperHemisphere) {
      z *= -1;
    }
    // Converts xyz to lat lon
    return [c * Math.atan2(y, x), c * Math.asin(z / r)];
  };
};

planeErrors = function(axesCovariance, axes, opts = {}) {
  var c1, ell, s, scales, sheet, stepFunc;
  // Get a single level of planar errors (or the
  // plane's nominal value) as a girdle
  if (opts.n == null) {
    opts.n = 100;
  }
  if (opts.upperHemisphere == null) {
    opts.upperHemisphere = true;
  }
  sheet = opts.sheet || 'nominal';
  if (axes == null) {
    axes = identity;
  }
  if (opts.traditionalLayout == null) {
    opts.traditionalLayout = true;
  }
  s = axesCovariance.map(Math.sqrt);
  axes = transpose(axes);
  scales = {
    upper: 1,
    lower: -1,
    nominal: 0
  };
  c1 = scales[sheet];
  if (opts.upperHemisphere) {
    c1 *= -1;
  }
  // Flip upper and lower rings
  if (axes[2][2] < 0) {
    c1 *= -1;
  }
  stepFunc = function(a) {
    var e, i, k, len, results;
    // Takes an array of [cos(a),sin(a)]
    e = [a[0], a[1], s[2] * c1];
    results = [];
    for (k = 0, len = axes.length; k < len; k++) {
      i = axes[k];
      results.push(sdot(e, i));
    }
    return results;
  };
  ell = ellipse(opts);
  return ell(s[0], s[1]).map(stepFunc).map(cart2sph(opts));
};

normalErrors = function(axesCovariance, axes, opts = {}) {
  var c1, ell, i, k, s, scales, stepFunc, v0;
  // Get a single level of planar errors (or the
  // plane's nominal value) as a girdle

  // Should use adaptive resampling
  // https://bl.ocks.org/mbostock/5699934
  if (opts.n == null) {
    opts.n = 100;
  }
  if (opts.upperHemisphere == null) {
    opts.upperHemisphere = true;
  }
  if (opts.traditionalLayout == null) {
    opts.traditionalLayout = true;
  }
  if (opts.sheet == null) {
    opts.sheet = 'upper';
  }
  if (axes == null) {
    axes = identity;
  }
  if (opts.level == null) {
    opts.level = 1;
  }
  scales = {
    upper: 1,
    lower: -1
  };
  s = axesCovariance.map(Math.sqrt);
  axes = transpose(axes);
  v0 = scales[opts.sheet];
  c1 = 1 * v0;
  if (opts.upperHemisphere) {
    c1 *= -1;
  }
  c1 *= opts.level;
  if (axes[2][2] < 0) {
    for (i = k = 0; k <= 2; i = ++k) {
      axes[i] = axes[i].map(function(d) {
        return d * -1;
      });
    }
  }
  //c1 *= -1
  stepFunc = function(es) {
    var e, l, len, results;
    e = es.map(function(d, i) {
      return -d * c1 * s[2] / s[i];
    });
    e.push(norm(es) * v0);
    results = [];
    for (l = 0, len = axes.length; l < len; l++) {
      i = axes[l];
      results.push(sdot(e, i));
    }
    return results;
  };
  ell = ellipse(opts);
  return ell(s[0], s[1]).map(stepFunc).map(cart2sph(opts));
};

combinedErrors$1 = function(sv, ax, opts = {}) {
  var func, out;
  func = function(type) {
    opts.sheet = type;
    opts.degrees = true;
    return planeErrors(sv, ax, opts);
  };
  return out = {
    nominal: func('nominal'),
    upper: func('upper'),
    lower: func('lower')
  };
};

convolveAxes = function(axes, sv) {
  var i, j, k, l, ref, ref1, residual;
  // Convolve unit-length principal axes
  // with singular values to form vectors
  // representing the orientation and magnitude
  // of hyperbolic axes
  // In case we don't pass normalized axes
  [residual, axes] = deconvolveAxes(axes);
  for (i = k = 0, ref = axes.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
    for (j = l = 0, ref1 = axes.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
      axes[j][i] *= sv[i];
    }
  }
  return axes;
};

deconvolveAxes = function(axes) {
  var ax, i, j, k, l, ref, ref1, sv;
  // Deconvolve unit-length principal axes and
  // singular values from premultiplied principal axes
  // Inverse of `convolveAxes`
  ax = transpose(axes);
  sv = ax.map(norm);
  for (i = k = 0, ref = axes.length; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
    for (j = l = 0, ref1 = axes.length; 0 <= ref1 ? l < ref1 : l > ref1; j = 0 <= ref1 ? ++l : --l) {
      axes[j][i] /= sv[i];
    }
  }
  return [sv, axes];
};




var math = Object.freeze({
	get planeErrors () { return planeErrors; },
	get normalErrors () { return normalErrors; },
	get combinedErrors () { return combinedErrors$1; },
	get transpose () { return transpose; },
	get convolveAxes () { return convolveAxes; },
	get deconvolveAxes () { return deconvolveAxes; }
});

var cloneOptions;

cloneOptions = function(obj, newProps) {
  var a, k;
  a = {};
  for (k in obj) {
    a[k] = newProps[k] || obj[k];
  }
  return a;
};

var __createErrorEllipse;
var combinedErrors;
var createErrorEllipse;
var createErrorSurface;
var createFeature;
var createGroupedPlane;
var createNominalPlane;
var d3;
var flipAxesIfNeeded;

d3 = require('d3');

require('d3-selection-multi');

combinedErrors = combinedErrors$1;

createFeature = function(type, coordinates) {
  return {
    type: 'Feature',
    geometry: {
      type: type,
      coordinates: coordinates
    }
  };
};

createErrorSurface = function(d) {
  var a, e, f;
  // Function that turns orientation
  // objects into error surface
  e = [d.lower, d.upper.reverse()];
  f = createFeature("Polygon", e);
  a = d3.geoArea(f);
  if (a > 2 * Math.PI) {
    f = createFeature("Polygon", e.map(function(d) {
      return d.reverse();
    }));
  }
  if (f.properties == null) {
    f.properties = {};
  }
  f.properties.area = a;
  return f;
};

createNominalPlane = function(d) {
  return createFeature('LineString', d.nominal);
};

flipAxesIfNeeded = function(axes) {
  if (axes[2][2] < 0) {
    axes[2] = axes[2].map(function(e) {
      return -e;
    });
  }
  return axes;
};

createGroupedPlane = function(opts) {
  if (opts.nominal == null) {
    opts.nominal = true;
  }
  return function(p) {
    var axes, covariance, e, el, hyperbolic_axes;
    ({hyperbolic_axes, axes, covariance} = p);
    if (hyperbolic_axes == null) {
      // To preserve compatibility
      hyperbolic_axes = covariance;
    }
    // Make sure axes are not inverted
    axes = flipAxesIfNeeded(axes);
    e = combinedErrors(hyperbolic_axes, axes, opts);
    el = d3.select(this);
    el.append("path").datum(createErrorSurface(e)).attr('class', 'error');
    if (!opts.nominal) {
      return;
    }
    // Create nominal plane
    return el.append("path").datum(createNominalPlane(e)).attr('class', 'nominal');
  };
};

__createErrorEllipse = function(opts) {
  var createEllipse;
  //Function generator to create error ellipse
  //for a single error level
  return createEllipse = function(p) {
    var axes, coords, covariance, f, f_, hyperbolic_axes, v;
    ({hyperbolic_axes, axes, covariance} = p);
    if (hyperbolic_axes == null) {
      // To preserve compatibility
      hyperbolic_axes = covariance;
    }
    f_ = function(sheet) {
      var a, e, f;
      opts.sheet = sheet;
      e = normalErrors(hyperbolic_axes, axes, opts);
      f = createFeature("Polygon", [e]);
      // Check winding (note: only an issue with non-traditional
      // stereonet axes)
      a = d3.geoArea(f);
      if (a > 2 * Math.PI) {
        f = createFeature("Polygon", [e.reverse()]);
        a = d3.geoArea(f);
      }
      f.properties = {
        area: a,
        level: opts.level,
        sheet: sheet
      };
      return f;
    };
    v = ['upper', 'lower'].map(f_);
    coords = v.map(function(d) {
      return d.geometry.coordinates;
    });
    f = createFeature("MultiPolygon", coords);
    f.properties = v[0].properties;
    return f;
  };
};

createErrorEllipse = function(opts) {
  var __fnAtLevel, levels;
  // Level can be single or array of error levels
  if (opts.level == null) {
    opts.level = 1;
  }
  levels = opts.level;
  __fnAtLevel = function(l) {
    var o1;
    o1 = cloneOptions(opts, {
      level: l
    });
    return __createErrorEllipse(o1);
  };
  if (Array.isArray(levels)) {
    // Return an array of functions, one for each
    // level of the ellipse to be generated
    return levels.map(__fnAtLevel);
  } else {
    // Return a single function for the specified
    // level
    return __fnAtLevel(levels);
  }
};




var functions = Object.freeze({
	get plane () { return createGroupedPlane; },
	get errorSurface () { return createErrorSurface; },
	get nominalPlane () { return createNominalPlane; },
	get errorEllipse () { return createErrorEllipse; }
});

var d;

d = {
  type: 'Feature',
  geometry: {
    type: 'LineString',
    coordinates: [[180, 0], [-90, 0], [0, 0], [90, 0], [180, 0]]
  }
};

var horizontal = function(stereonet) {
  var labelDistance;
  labelDistance = 4;
  return function() {
    var da, g, l, margin, sz, v;
    da = stereonet.overlay();
    g = da.append('g').attr('class', 'horizontal');
    g.append('path').datum(d);
    sz = stereonet.size();
    margin = stereonet.margin();
    l = g.append('g').attrs({
      class: 'labels',
      transform: `translate(${margin} ${sz / 2})`
    });
    l.append('text').text('E').attrs({
      class: 'axis-label',
      transform: `translate(${sz - 2 * margin} 0)`,
      'text-anchor': 'start',
      dx: labelDistance
    });
    l.append('text').text('W').attrs({
      class: 'axis-label',
      'text-anchor': 'end',
      dx: -labelDistance
    });
    // Vertical labels (may split out later)
    v = da.append('g').attrs({
      class: 'vertical',
      transform: `translate(${sz / 2} ${margin})`
    });
    v.append('line').attrs({
      y2: labelDistance
    });
    v.append('line').attrs({
      transform: `translate(0 ${sz - 2 * margin})`,
      y2: -labelDistance
    });
    return v.append('text').text('Vertical').attrs({
      class: 'axis-label',
      'alignment-baseline': 'baseline',
      'text-anchor': 'middle',
      dy: -labelDistance - 4
    });
  };
};

var d2r;

d2r = Math.PI / 180;

var vertical = function(stereonet) {
  return function(opts = {}) {
    var a, at, az, dip, dy, feat, g, grat, innerRadius, labels, locs, lon, m, proj, sel, v, x;
    if (opts.startOffset == null) {
      opts.startOffset = 10;
    }
    // correct for start at bottom
    opts.startOffset += 100;
    if (opts.labelPadding == null) {
      opts.labelPadding = 8;
    }
    g = stereonet.overlay();
    grat = stereonet.graticule();
    console.log(grat);
    labels = ["N", "E", "S", "W"];
    locs = [0, 90, 180, 270];
    az = g.append('g').attr('class', 'azimuthLabels');
    m = stereonet.margin();
    innerRadius = stereonet.size() / 2 - m;
    sel = az.selectAll('text').data(labels);
    sel.enter().append('text').text(function(d) {
      return d;
    }).attrs(function(d, i) {
      var angle, szm;
      szm = innerRadius + m;
      angle = (locs[i] - 90) * Math.PI / 180;
      return {
        transform: `translate(${szm} ${szm})`,
        x: Math.cos(angle) * (innerRadius + opts.labelPadding),
        y: Math.sin(angle) * (innerRadius + opts.labelPadding)
      };
    });
    dip = g.append('g').attr('class', 'dipLabels');
    lon = 220;
    feat = function(d) {
      return {
        type: 'Feature',
        label: `${d}°`,
        geometry: {
          type: 'Point',
          coordinates: [lon, -90 + d]
        }
      };
    };
    dy = 8;
    a = stereonet.clipAngle();
    v = (function() {
      var j, ref, results;
      results = [];
      for (x = j = 5, ref = a; j <= ref; x = j += 5) {
        results.push(x);
      }
      return results;
    })();
    proj = stereonet.projection();
    sel = dip.selectAll('text').data(v.map(feat));
    sel.enter().append('text').text(function(d) {
      return d.label;
    }).attr("transform", function(d) {
      v = proj(d.geometry.coordinates);
      return `translate(${v[0]}, ${v[1]}) rotate(${180 - lon})`;
    });
    at = {
      class: 'outer',
      dy: -dy
    };
    // Labels
    az.append('text').attrs(at).append('textPath').text('Azimuth →').attrs({
      'xlink:href': '#sphere',
      startOffset: `${innerRadius * opts.startOffset * d2r}`,
      method: 'stretch'
    });
    return dip.append('text').attrs(at).append('textPath').text('Dip').attrs({
      method: 'stretch',
      'xlink:href': '#sphere',
      startOffset: `${innerRadius * 70 * d2r}`
    });
  };
};

/*
Stereonet labeling:
Based heavily on http://bl.ocks.org/dwtkns/4686432

TODO: integrate text halos
http://bl.ocks.org/nitaku/aff4f425e7959290a1f7
*/
var geoDistance;
var geoPath;
var labels;

({geoPath, geoDistance} = require('d3'));

labels = [
  {
    name: 'N',
    c: [180,
  0]
  },
  {
    name: 'E',
    c: [90,
  0]
  },
  {
    name: 'S',
    c: [0,
  0]
  },
  {
    name: 'W',
    c: [-90,
  0]
  }
];

var labels$1 = function() {  //{name: 'Up', c: [0,90]}
  //{name: 'Down', c: [0,-90]}
  var i, l, len;
  for (i = 0, len = labels.length; i < len; i++) {
    l = labels[i];
    l.type = 'Feature';
    l.geometry = {
      type: 'Point',
      coordinates: l.c
    };
  }
  return function(stereonet) {
    var path, proj, svg, sz, updateLabels;
    sz = stereonet.size();
    proj = stereonet.projection();
    svg = stereonet.overlay();
    path = geoPath().projection(proj).pointRadius(1);
    updateLabels = function() {
      var centerPos, width;
      console.log("Updating labels");
      proj = this.projection();
      centerPos = proj.invert([sz / 2, sz / 2]);
      width = stereonet.size();
      return svg.selectAll(".label").attr('alignment-baseline', 'middle').style('text-shadow', "-2px -2px white, -2px 2px white, 2px 2px white, 2px -2px white, -2px 0 white, 0 2px white, 2px 0 white, 0 -2px white").attr("text-anchor", function(d) {
        var x;
        x = proj(d.geometry.coordinates)[0];
        if (x < width / 2 - 20) {
          return 'end';
        }
        if (x < width / 2 + 20) {
          return 'middle';
        }
        return 'start';
      }).attr("transform", function(d) {
        var offset, offsetY, x, y;
        [x, y] = proj(d.geometry.coordinates);
        offset = x < width / 2 ? -5 : 5;
        offsetY = 0;
        if (y < width / 2 - 20) {
          offsetY = -5;
        }
        if (y > width / 2 + 20) {
          offsetY = 5;
        }
        return `translate(${x + offset},${y - 2 + offsetY})`;
      }).style("display", function(d) {
        d = geoDistance(centerPos, d.geometry.coordinates);
        if (d > Math.PI / 2 + 0.01) {
          return 'none';
        } else {
          return 'inline';
        }
      });
    };
    svg.append("g.points").selectAll("path").data(labels).enter().append("path.point").attr("d", path);
    svg.append("g.labels").selectAll("text").data(labels).enter().append("text.label").text(function(d) {
      return d.name;
    });
    updateLabels.apply(stereonet);
    return stereonet.on('rotate', updateLabels);
  };
};

var chroma;
var d3$2;
var getterSetter;
var opts;

d3$2 = require('d3');

chroma = require('chroma-js');

require('d3-selection-multi');

opts = {
  degrees: true,
  traditionalLayout: false,
  adaptive: false,
  n: 200, // Bug if we go over 60?
  level: 1 // 95% ci for 3 degrees of freedom
};

getterSetter = function(main) {
  return function(p, fn) {
    return function() {      // A generic wrapper
      // to get/set variables
      if (arguments.length > 0) {
        fn(...arguments);
        return main;
      } else {
        return p();
      }
    };
  };
};

exports.Stereonet = function() {
  var _, __getSet, __redraw, __setScale, clipAngle, data, dataArea, dispatch, drawEllipses, drawPlanes, el, ell, ellipses, f, graticule, margin, overlay, path, planes, proj, s, scale, setGraticule, shouldClip;
  planes = null;
  ellipses = null;
  data = null;
  el = null;
  dataArea = null;
  overlay = null;
  margin = 20;
  scale = 300;
  clipAngle = 90;
  s = 0.00001;
  shouldClip = true;
  graticule = d3$2.geoGraticule().stepMinor([10, 10]).stepMajor([90, 10]).extentMinor([[-180, -80 - s], [180, 80 + s]]).extentMajor([[-180, -90 + s], [180, 90 - s]]);
  proj = d3$2.geoOrthographic().clipAngle(clipAngle).precision(0.01).rotate([0, 0]).scale(300);
  path = d3$2.geoPath().projection(proj);
  drawPlanes = function(data, o = {}) {
    var con, fn, sel;
    if (o.color == null) {
      o.color = '#aaaaaa';
    }
    if (el == null) {
      throw "Stereonet must be initialized to an element before adding data";
    }
    fn = createGroupedPlane(opts);
    con = dataArea.append('g').attr('class', 'planes');
    sel = con.selectAll('g.plane').data(data).enter().append('g').classed('plane', true).each(fn).each(function(d) {
      var color, e;
      if (typeof o.color === 'function') {
        color = o.color(d);
      } else {
        color = o.color;
      }
      e = d3$2.select(this);
      e.selectAll('path.error').attrs({
        fill: color
      });
      return e.selectAll('path.nominal').attrs({
        stroke: chroma(color).darken(.2).css()
      });
    });
    __redraw();
    return sel;
  };
  drawEllipses = function(data, o = {}) {
    var con, createEllipse, fn, sel;
    if (o.color == null) {
      o.color = '#aaaaaa';
    }
    if (el == null) {
      throw "Stereonet must be initialized to an element before adding data";
    }
    fn = createErrorEllipse(opts);
    createEllipse = function(d) {
      return d3$2.select(this).append('path').attr('class', 'error').datum(fn(d));
    };
    con = dataArea.append('g').attr('class', 'normal-vectors');
    sel = con.selectAll('g.normal').data(data).enter().append('g').classed('normal', true).each(createEllipse);
    sel.each(function(d) {
      var color, e;
      if (typeof o.color === 'function') {
        color = o.color(d);
      } else {
        color = o.color;
      }
      return e = d3$2.select(this).selectAll('path.error').attrs({
        fill: color
      });
    });
    __redraw();
    return sel;
  };
  __setScale = function(n) {
    var _pscale, radius;
    if (n != null) {
      // Scale the stereonet to an appropriate size
      scale = n;
    }
    radius = scale / 2 - margin;
    if (clipAngle < 89) {
      _pscale = radius / Math.sin(Math.PI / 180 * clipAngle);
      if (shouldClip) {
        proj.clipAngle(clipAngle);
      }
      proj.scale(_pscale).translate([scale / 2, scale / 2]);
    } else {
      proj.scale(radius).translate([scale / 2, scale / 2]);
    }
    path = d3$2.geoPath().projection(proj);
    if (el != null) {
      return el.attrs({
        height: scale,
        width: scale
      });
    }
  };
  __redraw = () => {
    if (el == null) {
      return;
    }
    return el.selectAll('path').attr('d', path);
  };
  dispatch = d3$2.dispatch('rotate', 'redraw');
  f = function(_el, opts = {}) {
    var drag, int;
    // This should be integrated into a reusable
    // component
    el = _el;
    __setScale(); // Scale the stereonet
    el.append("defs").append("path").datum({
      type: "Sphere"
    }).attrs({
      d: path,
      id: "sphere"
    });
    el.append("clipPath").attr("id", "neatline-clip").append("use").attr("xlink:href", "#sphere");
    el.append("use").attrs({
      class: 'background',
      fill: 'white',
      stroke: '#aaaaaa'
    });
    int = el.append('g').attrs({
      class: 'interior'
    });
    int.append('path').datum(graticule).attrs({
      class: 'graticule',
      d: path
    });
    dataArea = int.append('g').attrs({
      class: 'data'
    });
    if (shouldClip) {
      el.append("use").attrs({
        class: 'neatline',
        "xlink:href": "#sphere"
      });
      int.attr('clip-path', "url(#neatline-clip)");
    }
    overlay = el.append("g").attrs({
      class: "overlay"
    });
    // Add dragging for debug purposes
    drag = d3$2.drag().on('drag', () => {
      proj.rotate([-d3$2.event.x, -d3$2.event.y]);
      dispatch.call('rotate', f);
      return __redraw();
    });
    el.call(drag);
    // Finally, draw all the paths at once
    return __redraw();
  };
  __getSet = getterSetter(f);
  // Getter-setter for data
  f.data = __getSet(function() {
    return data;
  }, (o) => {
    return data = o;
  });
  f.node = function() {
    return el;
  };
  f.margin = __getSet(function() {
    return margin;
  }, (o) => {
    return margin = o;
  });
  f.size = __getSet(function() {
    return scale;
  }, __setScale);
  f.innerSize = function() {
    return scale - margin;
  };
  f.projection = function() {
    return proj;
  };
  f.clip = __getSet(function() {
    return shouldClip;
  }, function(c) {
    return shouldClip = c;
  });
  f.on = function(event, callback) {
    return dispatch.on(event, callback);
  };
  setGraticule = function(lon, lat) {
    //# Could also make this take a d3.geoGraticule object ##
    s = 0.00001;
    return graticule = d3$2.geoGraticule().stepMinor([lon, lat]).stepMajor([90, lat]).extentMinor([[-180, -90 + lat - s], [180, 90 - lat + s]]).extentMajor([[-180, -90 + s], [180, 90 - s]]);
  };
  f.graticule = __getSet(function() {
    return graticule;
  }, setGraticule);
  _ = function(c) {
    if (c === 'vertical') {
      c = [0, 90];
    }
    proj.rotate(c);
    if (el != null) {
      return __redraw();
    }
  };
  f.center = __getSet(function() {
    return proj.rotate;
  }, _);
  _ = function(c) {
    clipAngle = c;
    proj.rotate([0, -90]);
    __setScale();
    return f;
  };
  f.clipAngle = __getSet(function() {
    return clipAngle;
  }, _);
  f.planes = drawPlanes;
  f.draw = __redraw;
  f.path = function() {
    return path;
  };
  f.call = function(fn, ...args) {
    fn(f, ...args);
    return f;
  };
  ell = function() {
    var attrs, data_, fn, o, sel;
    // Same call signature as d3.Selection.data
    attrs = null;
    data_ = null;
    sel = null;
    fn = null;
    o = function(el_) {
      ell = createErrorEllipse(opts);
      sel = function() {
        return el_.selectAll('path.ellipse').data(data_.map(ell), fn);
      };
      sel().enter().append('path').attr('class', "ellipse").attrs(attrs).exit().remove();
      if (el != null) {
        __redraw();
      }
      return sel;
    };
    __getSet = getterSetter(o);
    o.data = __getSet(data_, function(d, f) {
      data_ = d;
      return fn = f;
    });
    o.attrs = __getSet(attrs, function(o) {
      attrs = o;
      if (sel != null) {
        return sel().attrs(attrs);
      }
    });
    o.selection = sel;
    return o;
  };
  f.ellipses = drawEllipses;
  f.dataArea = function() {
    return dataArea;
  };
  f.overlay = function() {
    return overlay;
  };
  f.horizontal = horizontal(f);
  f.vertical = vertical(f);
  return f;
};

exports.opacityByCertainty = function(colorFunc) {
  var darkenStroke;
  darkenStroke = 0.2;
  return function(d, i) {
    var al, alphaScale, color, e, fill, stroke, v;
    e = d3$2.select(this);
    alphaScale = d3$2.scaleLinear().range([0.8, 0.1]).domain([0, 5]);
    alphaScale.clamp(true);
    al = alphaScale(d.max_angular_error);
    color = chroma(colorFunc(d));
    fill = color.alpha(al).css();
    stroke = color.alpha(al + darkenStroke).css();
    return v = e.selectAll('path.error').attrs({fill, stroke});
  };
};

// Entrypoint for importing components
// from node.js

exports.functions = functions;
exports.math = math;
exports.positionLabels = labels$1;
