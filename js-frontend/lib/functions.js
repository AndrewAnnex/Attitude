// Generated by CoffeeScript 1.12.6
var __createErrorEllipse, cloneOptions, combinedErrors, createErrorEllipse, createErrorSurface, createFeature, createGroupedPlane, createNominalPlane, d3, math, rewind;

d3 = require('d3');

require('d3-selection-multi');

rewind = require('geojson-rewind');

math = require('./math');

cloneOptions = require('./util').cloneOptions;

combinedErrors = math.combinedErrors;

createFeature = function(type, coordinates) {
  return {
    type: 'Feature',
    geometry: {
      type: type,
      coordinates: coordinates
    }
  };
};

createErrorSurface = function(d) {
  var a, e, f;
  e = [d.lower, d.upper.reverse()];
  f = createFeature("Polygon", e);
  a = d3.geoArea(f);
  if (a > 2 * Math.PI) {
    f = createFeature("Polygon", e.map(function(d) {
      return d.reverse();
    }));
  }
  if (f.properties == null) {
    f.properties = {};
  }
  f.properties.area = a;
  return f;
};

createNominalPlane = function(d) {
  return createFeature('LineString', d.nominal);
};

createGroupedPlane = function(opts) {
  if (opts.nominal == null) {
    opts.nominal = true;
  }
  return function(p) {
    var axes, covariance, e, el, hyperbolic_axes;
    hyperbolic_axes = p.hyperbolic_axes, axes = p.axes, covariance = p.covariance;
    if (hyperbolic_axes == null) {
      hyperbolic_axes = covariance;
    }
    e = combinedErrors(hyperbolic_axes, axes, opts);
    el = d3.select(this);
    el.append("path").datum(createErrorSurface(e)).attrs({
      "class": 'error'
    });
    if (!opts.nominal) {
      return;
    }
    return el.append("path").datum(createNominalPlane(e)).attrs({
      "class": 'nominal'
    });
  };
};

__createErrorEllipse = function(opts) {
  var createEllipse;
  return createEllipse = function(p) {
    var axes, coords, covariance, f, f_, hyperbolic_axes, v;
    hyperbolic_axes = p.hyperbolic_axes, axes = p.axes, covariance = p.covariance;
    if (hyperbolic_axes == null) {
      hyperbolic_axes = covariance;
    }
    f_ = function(sheet) {
      var a, e, f;
      opts.sheet = sheet;
      e = math.normalErrors(hyperbolic_axes, axes, opts);
      f = createFeature("Polygon", [e]);
      a = d3.geoArea(f);
      if (a > 2 * Math.PI) {
        f = createFeature("Polygon", [e.reverse()]);
        a = d3.geoArea(f);
      }
      f.properties = {
        area: a,
        level: opts.level,
        sheet: sheet
      };
      return f;
    };
    v = ['upper', 'lower'].map(f_);
    coords = v.map(function(d) {
      return d.geometry.coordinates;
    });
    f = createFeature("MultiPolygon", coords);
    f.properties = v[0].properties;
    return f;
  };
};

createErrorEllipse = function(opts) {
  var __fnAtLevel, levels;
  if (opts.level == null) {
    opts.level = 1;
  }
  levels = opts.level;
  __fnAtLevel = function(l) {
    var o1;
    o1 = cloneOptions(opts, {
      level: l
    });
    return __createErrorEllipse(o1);
  };
  if (Array.isArray(levels)) {
    return levels.map(__fnAtLevel);
  } else {
    return __fnAtLevel(levels);
  }
};

module.exports = {
  plane: createGroupedPlane,
  errorSurface: createErrorSurface,
  nominalPlane: createNominalPlane,
  errorEllipse: createErrorEllipse
};
