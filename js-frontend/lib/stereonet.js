// Generated by CoffeeScript 1.12.6
var Stereonet, centerPoints, d3, projections, rewind, selectedRotation,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

d3 = require('d3');

require('d3-selection-multi');

rewind = require('geojson-rewind');

projections = {
  wulff: d3.geoAzimuthalEqualArea,
  schmidt: d3.geoAzimuthalEquidistant
};

selectedRotation = 1;

centerPoints = [[[0, 0], 'North'], [[0, 90], 'Vertical']];

Stereonet = (function() {
  Stereonet.prototype.defaults = {
    width: 500,
    height: 500,
    margin: 0,
    projCenter: [0, 0],
    traditional: false
  };

  function Stereonet(el, options) {
    var coords, data, defs, graticule, k, ref, traditional, v;
    if (options == null) {
      options = {};
    }
    this.draw = bind(this.draw, this);
    this.addPath = bind(this.addPath, this);
    this.addEllipse = bind(this.addEllipse, this);
    this.addGirdle = bind(this.addGirdle, this);
    this.reflowProjection = bind(this.reflowProjection, this);
    ref = this.defaults;
    for (k in ref) {
      v = ref[k];
      this[k] = options[k] || this.defaults[k];
    }
    this.center = [this.width / 2, this.height / 2];
    this.setupProjection();
    this.drag = d3.drag().subject((function(_this) {
      return function(d) {
        var r;
        if (d == null) {
          r = _this.projection.rotate();
          ({
            x: r[0],
            y: -r[1]
          });
        }
        return d;
      };
    })(this)).on('drag', (function(_this) {
      return function() {
        return _this.reflowProjection([d3.event.x, -d3.event.y]);
      };
    })(this)).on('start', function(d) {
      d3.event.sourceEvent.stopPropagation();
      return d3.select(this).classed('dragging', true);
    }).on('end', function(d) {
      return d3.select(this).classed('dragging', false);
    });
    graticule = d3.geoGraticule();
    this.setCenter = (function(_this) {
      return function() {
        var coords, loc;
        selectedRotation = selectedRotation === 1 ? 0 : 1;
        loc = centerPoints[selectedRotation];
        coords = loc[0].slice();
        if (!_this.traditional) {
          coords[1] *= -1;
        }
        _this.reflowProjection(coords);
        return _this.topLabel.text(loc[1]);
      };
    })(this);
    this.svg = d3.select(el).append("svg").attr("width", this.width).attr("height", this.height).call(this.drag).on('click', this.setCenter);
    this.topLabel = this.svg.append('text').attrs({
      x: 250,
      y: 10,
      'text-align': 'center'
    });
    this.svg.append("path").datum(graticule).attrs({
      "class": "graticule",
      d: this.path,
      fill: 'none'
    });
    defs = this.svg.append("defs");
    defs.append("path").datum({
      type: "Sphere"
    }).attrs({
      id: "sphere",
      d: this.path
    });
    defs.append("svg:clipPath").attrs({
      id: "clip"
    }).append('use').attrs({
      'xlink:href': '#sphere'
    });
    this.frame = this.svg.append('g').attrs({
      "class": 'dataFrame',
      'clip-path': 'url(#clip)'
    });
    this.dataArea = this.frame.append('g');
    this.svg.append('use').attrs({
      'xlink:href': '#sphere',
      fill: 'none',
      stroke: 'black',
      'stroke-width': 2
    });
    traditional = false;
    if (traditional) {
      coords = [[90, 0], [0, 90], [-90, 0], [0, -90], [90, 0]];
    } else {
      coords = [[0, 0], [90, 0], [180, 0], [-90, 0], [0, 0]];
    }
    data = {
      type: 'Feature',
      geometry: {
        type: 'LineString',
        coordinates: coords
      }
    };
    this.frame.append('path').datum(data).attrs({
      "class": 'horizontal',
      stroke: 'black',
      'stroke-width': 2,
      'stroke-dasharray': '2 4',
      fill: 'none'
    });
    this.setCenter();
  }

  Stereonet.prototype.reflowProjection = function(loc) {
    this.projection.rotate(loc);
    return this.svg.selectAll('path').attrs({
      d: this.path
    });
  };

  Stereonet.prototype.setupProjection = function(type) {
    if (type == null) {
      type = 'wulff';
    }
    this.projectionType = type;
    this.projection = projections[type]().clipAngle(90 - 1e-3).scale(this.width / 3).translate(this.center).precision(.1);
    return this.path = d3.geoPath().projection(this.projection);
  };

  Stereonet.prototype.addGirdle = function(d, opts) {
    var coords, data, level;
    if (opts["class"] == null) {
      opts["class"] = 'main';
    }
    level = opts.level || 1;
    coords = [d.upper, d.lower];
    data = {
      type: 'Feature',
      geometry: {
        type: 'Polygon',
        coordinates: coords
      }
    };
    return this.dataArea.append('path').datum(rewind(data)).attrs({
      "class": "errors " + opts["class"],
      'fill-opacity': Math.pow(1 / (level * 2), 1.5)
    });
  };

  Stereonet.prototype.addEllipse = function(d, opts) {
    var data, level;
    console.log("Adding ellipse");
    if (!opts["class"]) {
      opts["class"] = 'main';
    }
    level = opts.level || 1;
    data = {
      type: 'Feature',
      geometry: {
        type: 'Polygon',
        coordinates: [d]
      }
    };
    return this.dataArea.append('path').datum(rewind(data)).attrs({
      "class": "errors " + opts["class"],
      'fill-opacity': Math.pow(1 / (level * 2), 1.5)
    });
  };

  Stereonet.prototype.addPath = function(d, opts) {
    var data;
    if (opts["class"] == null) {
      opts["class"] = 'main';
    }
    data = {
      type: 'Feature',
      geometry: {
        type: 'LineString',
        coordinates: d
      }
    };
    return this.dataArea.append('path').datum(data).attrs({
      "class": "nominal " + opts["class"]
    });
  };

  Stereonet.prototype.draw = function() {
    return this.frame.selectAll('path').attrs({
      d: this.path
    });
  };

  return Stereonet;

})();

module.exports = Stereonet;
